/**************************************************************************************
* strstr（）函数的使用说明
* 函数作用：
* 1、strstr() 函数搜索一个字符串在另一个字符串中的第一次出现。
* 2、找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址；
* 3、如果未找到所搜索的字符串，则返回NULL。
* 函数原型：
*   char *strstr(char *str1, const char *str2);   //返回值为字符型指针
*		str1: 被查找目标
*		str2: 要查找对象
*
***************************************************************************************/

/************************************************************
*情景1：用于单次匹配返回的是匹配成功的字符串以及后面的字符串
*情景2：用于单次匹配返回的是子串在母串的位置
*************************************************************/
/*
#include <stdio.h>
#include <string.h>

int main()
{
    //对于指向字符串字面量的指针，应该声明为const char* 类型
    const char* s = "GoldenGlobalView";
    const char* l = "lob";
    const char* p;

    p = strstr(s, l);

    if (p != NULL)
    {
        printf("%s\n", p);//情景1
        printf("%zu\n", p - s + 1);//情景2  为什么要用%zu打印，原因是：编译器将 size_t（strstr 函数的返回类型）解释为 __int64 类型。
        //为了解决这个警告，你可以使用正确匹配参数类型的格式字符串。在这种情况下，size_t 的正确格式说明符是 %zu
    }
    else
    {
        printf("NotFound!");
    }

    return 0;
}
*/


/******************************************************************************
*情景三：用于多次匹配知道母串结束记录子串在母串中出现的次数
*******************************************************************************/
#include <stdio.h>
#include <string.h>

int main()
{
    int  k = 0;
    char a1[1001], a2[1001];
    scanf_s("%s %s", a1, sizeof(a1), a2, sizeof(a2));
    char* p;
    p = a1;
    while ((p = strstr(p, a2)) != NULL)
    {
        k++;
        p++;
    }
    printf("%d", k);

    return 0;
}

